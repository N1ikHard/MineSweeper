#include<SFML/Graphics.hpp>
#include<time.h>
using namespace sf;

	int main() 
	{
		//Убрать консоль при открытии приложения получилось так:
		// Название Проекта->Свойства->Компоновщик->Система->Подсистема
		//(Project Name->Properties->Linker->System->SubSystem и выбираем Windows(/ SUBSYSTEM:WINDOWS).
		// Название Проекта->Свойства->Компоновщик->Дополнительно->Точка входа
		//Project Name->Properties->Linker->Advanced->Entery Point и вписать mainCRTStartup.
		
		srand(time(0));

		// Создание окна с заданным размером и заголовком
		RenderWindow app(VideoMode(400, 400), "Minesweeper");

		//размер клетки 32 пикселя
		int w = 32;
		//В уроке размер сетки был 12х12 , изменил на 11х11 , ничего не изменилось
		int grid[11][11];
		int sgrid[11][11];
		
		Texture t;
		t.loadFromFile("images/tiles.jpg");
		Sprite s(t);

		//Здесь и в дальнейшем итерации начинаются с 1 , связанно это с тем , что далее в цикле
		//идет установка текстуры на окне , если делать отсчет с 0 , то клетки уйдут в левый верхний угол
		for (int i = 1; i <= 10; i++)
			for (int j = 1; j <= 10; j++)
			{
				sgrid[i][j] = 10;				//Все поля заполняются непрозрачной стенкой		
				if (rand() % 5 == 0)			//Если случайное число делится на 5 , то текущая клетка - мина
					grid[i][j] = 9;				//Ей присваивается порядковый номер мины по текстуре
				else 
					grid[i][j] = 0;				//Иначе клетка - непроницаемое значение
			}

		//цикл по которому определяется сколько рядом с клеткой находится мин
		for(int i=1;i<=10 ;i++)
			for (int j = 1; j <= 10;j++)
			{
				int n = 0;						//Значение клетки , если рядом есть мина , то счетчик увеличивается

				if (grid[i][j] == 9)		    //Если этот блок - мина , то пропустить и продолжить
					continue;
				if (grid[i + 1][j] == 9)
					n++;
				if (grid[i][j + 1] == 9)
					n++;
				if (grid[i - 1][j] == 9)
					n++;
				if (grid[i][j - 1] == 9)
					n++;
				if (grid[i + 1][j + 1] == 9)
					n++;
				if (grid[i - 1][j - 1] == 9)
					n++;
				if (grid[i - 1][j + 1] == 9)
					n++;
				if (grid[i + 1][j - 1] == 9)
					n++;
				grid[i][j] = n;					//Клетка принимает значение от счетчика
			}

		//Пока приложение работает
		while (app.isOpen())					
		{
			//Текущие координаты мышки на окне
			Vector2i pos = Mouse::getPosition(app);
			//Определяем клетку по координатам
			int x = pos.x / w;
			int y = pos.y / w;

			//Переменная события
			Event e;

			//polEvent(Event e) - Возвращает 1, если есть ожидающее событие, или 0, если его нет.
			while (app.pollEvent(e)) {

			//Если событие-"закрыться" , закрыть окно	
				if (e.type == Event::Closed)
					app.close();

			//Если событие клик мышкой
				if (e.type == Event::MouseButtonPressed)
					
					//
					if (e.key.code == Mouse::Left)
						sgrid[x][y] = grid[x][y];  //Принимается значение порядкового номера 

				    //Если правая кнопка мышки , то значение клетки  принимает изображение флажка
					else if (e.key.code == Mouse::Right)
						sgrid[x][y] = 11;		//Значение становится 11(порядковый номер флажка)
			}

			//Задний фон - белый
			app.clear(Color::White);

			//В этом цикле в окне устанавливаются текстуры
			for(int i=1;i<=10;i++)
				for (int j = 1; j <= 10; j++)
				{
					//Если по координатам , где мы нажали находится мышкой мина , то раскрыть поле
					//цикл успеет отработать и отобразит все клетки
					if(sgrid[x][y]==9)
						sgrid[i][j] = grid[i][j];
					
					//Установить размеры прямоугольной текстуры
					s.setTextureRect(IntRect(sgrid[i][j]*w, 0, w, w));
					
					//Установить координаты текстуры  номера по сетке* на пиксель размера одной клетки
					s.setPosition(i*w,j*w);

					//Отобразить в окне текстуру
					app.draw(s);
				}

			//Метод отображения изменений в окне.
			app.display();

		}
		return 0;
	}
